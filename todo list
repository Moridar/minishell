1. [fixed] Global variable to only recieve signal
1. [but] Need double checking the exit status value
2. [fixed] Cat error	 with std-in
4. [maybe fixed] Open minishell inside minishell (errors at pipex_get_path.c)
5. [maybe fixed] Running a command which is a dictory should return command not found
6. [fixed] get_path permission denied missing program name
7. [fixed] Remove hardcoded paths
8. [fixed] Run vim in minishell and other program.
[fixed] -. OLDPWD (Implement or remove)
[fixed] -. cd ../../../../../../../../../.. errored the histroy file???
-. Exit > filename should exit. 
-. Exit 50 | exit 50 should return 50.
-. Export without values should store a NULL
[fixed] -. UNSET should check identiifier
[fixed] -. unset should be able to unset several env var
-. One of the ft_strjoin was not NULL checked?
-. Handle adding empty env var
?. EXPORT :@ as metachar?
?. EXPORT += 
?. Maybe echo -nn
?. Sort envp


Original discussion: 
Hey! How are you? I am nervous. Don’t worry :D Im gonna log in.

Where should I clone

Why the global variable is showed twice?
Header file and .c file

Ok, makes sense.

I’m gonna open the project in vscode, is it OK?

What is the use for the global variable?

It stores the exit code of last execute. 

But, does it have to store just the signal value?

You need to use it just to catch the signal value, like the keyboard combination? 

For example, SIGINT(3)(ctrl + c) or SIGSEGV(11).. So, if you are using this global variable for something else, for example, to get the exit status of a process, that’s a fail.
Yeah I see. What’s the SIGSEGV? 
Segmentation fault (it’s an example, don’t worry, there are many signal values, those are the ones I remember :))

But, I can continue checking if I find something else. Do you agree guys?

Let’s try the first command.

Cool name. It looks like bash but it’s not bash haha yes we decided to use first letters of our names. Just for fun and it fits.

Ok, expected result, when I used env -I. No crashed found.

I thought the pipex would signal the result? No, basically what that sentence says is that this global variable should store just the number of the signal received, for example, when I press ctrl + c in your bash. I think the reason for that is to force you to not multiuse this global variable.

That’s weird, let’s try with the relative cat.

What if I try to read a file with cat.

So, for some reason cat is not working when there is no file provided or when it should lister the stdin.

I guess there’s a problem with the file descriptors handling. Because if they are handled correctly, cat should work without any arguments. It should read from stdin.

If you just call cat, yes.

Yes, so, it is always when a program need some info from stdin that it is not working as expected.

Let’s check ctrl+c and ctrl+d behaviors.

I think in that case, it’s a wrong return number.
Maybe echo?

It doesn’t matter. Good, I didn’t know that case, HAHAHA. See, you never stop learning.

Usually, if I put echo -nnnnnnn hello, it should work, but, it’s an undefined behavior of echo. So, it’s OK.
It also works if I do echo -nnnnn -nnnnn hello, for some reason, but, again, it’s an undefined behavior.

Weird, right?. But your behavior is ok.

Let’s test exit.

Exit works properly, good job.

I tried that. It’s fine because you should not handle open quotes in this mini shell at least. Yeah I thought it would print the ‘ and “ if it isn’t closed.

That’s the correct behavior.

Let’s check export now.
Do you decided to not sort the results of export? I haven’t thought of that. Yeah, it’s not necessary by the way. But, it could have been cool.
We can type env | sort.
Sure, but, again, using just export is an undefined behavior (if you could, you could have just decided not to print anything if you write just export). Difficult to believe, right? Yes true because we tested in bash and just get the behavior from there and it was always the same :) no undefined for us. But I can believe . So on the manual it is undefined. OK!

That’s why I’m still happy that you print something.

So, I guess you are not storing empty values, right?

I think this is also an undefined behavior.

With += export should append. But, I don’t think you should worry about it.


That’s the correct behavior.

Ok, export is fine for me.
Let’s move to unset then.

In unset, you need to do the same checks for the name than in export. You can recycle the functions for that propose.

It is when you put a weird character in the name of the variable (as you do in export)

Ok, let’s move to cd.

When you cd, you should go to HOME. We removed it, as the subject says there must be argument. Does it say that? Show me.

That’s true, I guess they added it when they changed the subject (September of last year). This is weird.

How do you handle cd? We can see the code. I guess there is something to fix there, usually it should move back as much as it can. So, with the command I just wrote, it should reach root

Maybe split the cmd and make a loop. No, it should handle it by default.

We are outside, I didn’t realize hahaha.

So, that command shouldn’t make your minishell to exit. No it shouldn’t, I think the history file made it exit. That’s the weird part of this. At least the exit status is correct.

I don’t think there’s much else to test with pwd.

Let me check if you update PWD and OLDPWD when you navigate through the directories. I think cd updates PWD, but it doesn’t update OLDPWD. OLDPWD is not changing. Probably you are just inheriting it from outside. Yeah, I guess we weren’t aware of what OLDPWD does, isn’t it the PWD when it enters the minishell. Actually, your minishell should empty OLDPWD when it starts. So it is the previous PWD? Yes, the value that you are seeing is the value that is coming from outside. Let’s test.

Now, because the value of OLDPWD is empty when I started a new bash, you are not inheriting it. But, it should be there empty. Do you get it?

Yes, because we copy envp from bash, if we changed it in bash then we also copy in in mminishell. But we should start with it empty. But then when we change the directory relatively or absolutely than w store the last value of pwd. Right? Absolute path. Yes the absolute path right. I wonder whats the point of OLDPWD? I just store the previous directory visited
I think we also decided not to implement it because we do not handle cd -
So we do not move to the OLD PWD ever. In that case, you should remove that variable from your initial environment variables. Why would you copy it then, we just copy whole envp. But, you are saying that you don’t handle that variable because it doesn’t make sense for you. So, why would you have it then? II dunno maybe if we run some program needs it. If a program needs that variable, is it maybe better to implement it then?
Do you implement the special symbols to separate the expansion of environment variables? No

So, then you can do special operations, for example what I tried to do (appending Bobby’s fractol to the path) we can using different seperator. Yeah

You are missing there, the program’s name.

Let’s add it to the path.

Why I can’t open a minishell inside a minishell? I should be possible.

I should say permission denied. Try to verify that as well. It can happened that you are not checking correctly when a program is in a directory that is in the PATH but it doesn’t have the permissions to execute. It can’t run bash either, should it be able to? I have no idea why it doesn’t. Me neither, show me in the code where you are running execve or where you check the paths.

Here is where is missing the name of the file (one of the errors we saw before).

Right. And then you exit, But there is not protected. I

The command doesn’t include a ‘/‘  There it is, you are just checking if the file exists, not if you have the permissions to execute it. Yeah so it found the file and return the cmdpath. You need to have a similar check. Also, if a folder is in a directory that it is in the path, get_path should also skip that folder. A folder by definition is an executable. So, be careful with folders, because access can find them with F_OK and X_OK. This func checks if it’s a folder. 

So, this is the wrong part. Yeah I see. Without / in the command it should assume it’s a command. So, basically you need to add in your get_path, to check if the path you found belongs to a directory. If it does, you should skip that path and continue to the next one. I’ll show you an example. It always skips the directory if a directory is inside a folder in the PATH.

We. Have them hardcoded. Yeah right. I guess you read the discussion in discord about why you should not do that.

That what happened with vim was weird. You really need to check your execution system.

That one we tested it in the beginning and it doesn’t work. You need to check your fd handling. All good, I guess I can finish the eval, in my laptop, so, I don’t take more your time. Wait wait, can I check the code a while?

So we start in main. And have three cases.
Interactive shell and non interactive shell 2 cases.
1 executing a command with -c
Another on e is executing files

Then we go to prompt for the first case
Read history, handle the signal for ctrl D and inside the loop we handle signal for ctrl+C.
For control D we handle it inside the loop I think when the line from headline prompt is NULL.

Can I test something?

That should work, built in can have redirections or pipes.

That should return 10 but not exit. 

OK, that correct for export, because it’s defining the variables, but in the child process, so, they get lost when you go to the parent process again.

But, from exit we should be able, at least get the return value.

Yeah, its a easy fix. Its set to ignore exit in child process. I guess it can run it and return will be right. 

Also with redirections. That’s the other thing, the message exit, should be printed in the stderr. Here I can see that you print it in stdout.

So, I can finish this in my laptop if it is ok for you. Remember that

Wow crushed us.

YEs, that was hard. But don’t remove the notes. Maybe we can use it? Yeah of course, Im gonna resume it into a list, we can work on. Yes, sure.

The thing I got about history is that it alleys written in the relative path? SO maybe it should somewhere in the absolute path.
That is why the permission failed? I think with ../…/./././ etc
He tried to create it in the root directory

But still it was good. A lot of edge cases.
I am not sure that everything is in the scope of the pdf But he checked a lot of things.
OLDPWD should be an easy implementation.
No options but with args

ok. What about g_signal? Is it a big change, I think we already return most. The pipex is returning correct already, we just send it to main.

Yes need to change that too.. It can be maybe a var in the struct data? This g_exit_tatus because we have data like everywhere yeah of course

This is eval copy, yeah we should list the errors. I need to go 